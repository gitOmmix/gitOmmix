#!/bin/env bash

# Boilerplate bash init
# Set strict mode
set -uo pipefail
IFS=$'\n\t'

# Test getopt
# Allow a command to fail with !’s side effect on errexit
# Use return value from ${PIPESTATUS[0]}, because ! hosed $?
! getopt --test > /dev/null 
if [[ ${PIPESTATUS[0]} -ne 4 ]]; then
    echo 'I’m sorry, `getopt --test` failed in this environment.'
    exit 1
fi

# Load git ommix functions
source /usr/share/git-ommix/functions

# Settings

# Global config
[[ -f "/etc/gitommix.conf" ]] && source "/etc/gitommix.conf"

# Local config
[[ -f "$HOME/.config/gitommix.conf" ]] && source "$HOME/.config/gitommix.conf"

CURRENT_DIR="$PWD"

# Parse arguments

# Test for the number of options, at least two (verb + object)
if [[ $# -lt 2 ]]; then
    echo "Insufficient number of arguments"
    usage root
fi

# Get verb and object
VERB="$1"
OBJECT="$2"
shift 2

# Default values
PROVIDER=$GIT_OMMIX_DEFAULT_PROVIDER
METHOD=
PATIENT=
SAMPLE=
DATE=`date +%Y-%m-%d`
ID=`base64 /dev/urandom | tr -d "/+=" | head -c 10`
INVALIDATE=
USE=
REVISION_OF=
MESSAGE2=
DEBUG=
FILES="*"

# getopt options
OPTIONS=p:s:m:d
LONGOPTS=provider:,method:,patient:,sample:,date:,id:,invalidate:,use:,revision_of:,message:,debug

# -temporarily store output to be able to check for errors
# -activate quoting/enhanced mode (e.g. by writing out “--options”)
# -pass arguments only via   -- "$@"   to separate them correctly
! PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTS --name "git-ommix" -- "$@")
if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
    # e.g. return value is 1
    #  then getopt has complained about wrong arguments to stdout
    usage root
    exit 2
fi

# Read getopt’s output this way to handle the quoting right:
eval set -- "$PARSED"

# Parse options
while true; do
    case "$1" in
        --provider)
            PROVIDER="$2"
            shift 2
            ;;
        --method)
            METHOD="$2"
            shift 2
            ;;
        -p|--patient)
            PATIENT="$2"
            shift 2
            ;;
        -s|--sample)
            SAMPLE="$2"
            shift 2
            ;;
        --date)
            DATE="$2"
            shift 2
            ;;
        --id)
            ID="$2"
            shift 2
            ;;
        --use)
            USE+=("$2")
            shift 2
            ;;
        --invalidate)
            INVALIDATE+=("$2")
            shift 2
            ;;
        --revision_of)
            REVISION_OF="$2"
            shift 2
            ;;
        -m|--message)
            MESSAGE2="$2"
            shift 2
            ;;
        -d|--debug)
            DEBUG="y"
            shift
            ;;
        --)
            shift
            break
            ;;
        *)
            echo "Programming error"
            exit 3
            ;;
    esac
done

FILES=${@:-$FILES}

# Output parameter values for debug
if [[ -n "$DEBUG" ]]; then
    echo "Verb: $VERB"
    echo "Object: $OBJECT"
    echo "Provider: $PROVIDER"
    echo "Method: $METHOD"
    echo "Patient: $PATIENT"
    echo "Sample: $SAMPLE"
    echo "Date: $DATE"
    echo "Id: $ID$"
    echo "Use: ${USE[@]}"
    echo "Invalidate: ${INVALIDATE[@]}"
    echo "Revision_of: $REVISION_OF"
    echo "Message: $MESSAGE2"
    echo "Files: $FILES"
fi

# Go to git ommix dir or create if it does not exist
mkdir -p "$GIT_OMMIX_REPO_DIR"
cd "$GIT_OMMIX_REPO_DIR"

# If patient is specified, try to go to the repo
if [[ -n "$PATIENT" ]]; then
    if [[ -d "$PATIENT" ]]; then
       cd "$PATIENT"
    else
        die "patient:$PATIENT is not a patient"
    fi
fi

# If specified, try to go to sample branch
if [[ -n "$SAMPLE" ]]; then
    if [[ `git rev-parse --verify "sample|$SAMPLE"` ]];then
        dbg git stash push
        dbg git checkout "sample|$SAMPLE"
        dbg git stash pop
    else
        die "sample:$SAMPLE is not a sample of patient:$PATIENT"
    fi
fi

case "$VERB" in
     add) add;;
     list) list;;
     get) get;;
     *) usage "root";;
esac
