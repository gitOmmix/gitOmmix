#!/bin/bash

###############################################################################
#
# Usage

function usage
{
    case "$1" in
        root) 
            echo "git ommix {verb} {object} [--options] [files]

Verbs:
- add
- list
- get

Git Ommix options:
- GIT_OMMIX_REPO_DIR : place to find patient repos
- GIT_OMMIX_LARGE_FILES : git ommix rules for large files
- GIT_OMMIX_DEFAULT_PROVIDER : set a default provider

Git ommix can be configured with the \$XDG_CONFIG/.gitommix file, or with environment variables.

Register bash completions with register completions.
" ;;
        add)
            echo "git ommix add {object} [--options] [--message]

Objects:
- patient
- sample
- data
- result
- diagnostic

# Patient 

Create patient repo with the given id.
Options :

 -i <id>

# Sample

Create the branch with the given sample id for the current or selected patient.

Options :

 -i <id>
 -p <patient>

# Data 

Add the FILES to data, with the given id, for the current or selected sample in the current or selected patient.
Data are always DERIVED_FROM the sample, but could be also be a REVISION_OF previous data. This can be set by pointing to a data commit to revise.
The data that has been revised can also be INVALIDATEd at the same time.

Options :

 -i <id>
 -p <patient>
 -s <sample>
 [--revision_of <data_hash>]
 [--invalidate]

# Result 

Options :

 -i <id> 
 -p <patient> 
 -s <sample> 
 --use <data_hash> 
 [--revision_of <result_hash>]
 [--invalidate]

# Diagnostic

Add a diagnostic with the given id, for the current or selected patient.
The diagnostic can USE multiple results and diagnostics, be the REVISION_OF multiple diagnostics, which can be INVALIDATEd at the same time.
The diagnostic branch pointers for the revised diagnostics are destroyed.

Options :

 -i <id>
 -p <patient>
 --use <result/diagnostic_hash>
 [--revision_of <diagnostic_hash>]
 [--invalidate]
" ;;
        list)
            echo "git ommix list {object}

Objects:
- patient(s)
- sample(s)
- data(s)
- result(s)
- diagnostic(s)
" ;;
    esac
    exit 0
}

###############################################################################
#
# Utility functions

# Print messages passed as arguments and exit in error
function die
{
    echo $@
    exit 2
}

# Redirect commands to &>/dev/null if not DEBUGging
function dbg
{
    if [[ "$DEBUG" == "debug" ]]; then
        "$@"
    elif [[ "$DEBUG" == "dry" ]];then
        echo "$@"
    else
        "$@" &>/dev/null
    fi
}

# Stash in place modifications
function stash
{
    git stash push
    "$@"
    git stash pop
}

###############################################################################
#
# Add functions

# Add patient
# Uses :
# - ID
function add_patient
{
    # The patient is a MSH:Patient and derives from nothing
    MESSAGE_ENTITY+="
:$OBJECT:$ID a MSH:Patient ."

    # Create the patient repo dir and data and result subdirs
    dbg mkdir --parents "$ID/data" || die "Unable to create a directory in the git ommix base directory at: $GIT_OMMIX_REPO_DIR
Please check your permissions"
    dbg mkdir --parents "$ID/result"

    # Go to the patient repo
    dbg cd "$ID"

    # Init git, git annex
    dbg git init
    dbg git annex init

    # Set some default options :
    # - make `cat` the default pager makes it easier to parse outputs
    # - set rule for annex usage
    dbg git config core.pager cat
    dbg git config annex.largefiles "$GIT_OMMIX_LARGE_FILES"

    # Rename the default branch to the patient ID
    dbg git checkout -b "patient|$ID"
}

# Add sample
# Uses :
# - ID
# - PATIENT
function add_sample
{
    # Create a new sample branch stemming from the patient branch
    dbg stash git checkout -b "sample|$ID" "patient|$PATIENT"

    if [[ "$METHOD" ]];then
    fi

}

# Add data|result
# Uses :
# - ID
# - PATIENT
# - SAMPLE
# - [USE data:<id> | <data_hash>] * n
# - [REVISION_OF data|result:<id> | <data|result_hash>]
# - [INVALIDATE data|result:<id> | <data|result_hash>] * n
function add_object
{
    # Copy all the given files to the $OBJECT folder recursively
    # FILES is unquoted to allow * expansion
    dbg cp ${FILES[@]} "$GIT_OMMIX_REPO_DIR/$PATIENT/$OBJECT" --recursive || die "Unable to copy files to the patient directory at: $GIT_OMMIX_REPO_DIR/$PATIENT/$OBJECT
Please check your permissions"

    # Add the $OBJECT folder to git
    dbg git add "$OBJECT"


    # REVISION_OF
    [[ "$REVISION_OF" ]] && revision_of

    # INVALIDATEs
    [[ "${#INVALIDATE[@]}" -gt 0 && "$METHOD" ]] && invalidate


            # check if existing data for this sample
            if ! `git log --oneline | grep --fixed-strings "$use" --quiet`;then
                die "$use is not the name of existing data in sample:$SAMPLE of patient:$PATIENT"
            fi

            local PROV_DERIVE+="
:$OBJECT:$ID prov:wasDerivedFrom :$use ."
            local PROV_USE+="
:method:$METHOD used :$use ."
        done
    fi
}

# Add diagnostic
# Uses :
# - ID
# - PATIENT
# - USE result|diagnostic:<id> | <result|diagnostic_hash>
# - [INVALIDATE diagnostic:<íd> | <diagnostic_hash>]
# - [REVISION_OF diagnostic:<id> | <diagnostic_hash>]
function add_diagnostic
{
    # If revision_of : commit must be the head of that branch, commit from that
    # REVISION_OF
    if [[ "$REVISION_OF" ]];then
        # TODO: validate_branch ?
        hash=$(validate_commit "diagnostic" "$REVISION_OF")
        revision_of

    fi

    # USE
    [[ "${#USE[@]}" -gt 0 ]] && use "(result|diagnostic)"

    # INVALIDATEs
    [[ "${#INVALIDATE[@]}" -gt 0 && "$METHOD" ]] && invalidate

}

# Add
function add
{
    base_prov

    case "$OBJECT" in
        patient)
            add_patient ;;

        *) # all next operations need a patient, continue matching
            [[ "$PATIENT" ]] || die "Please provide a --patient"
            [[ -d "$PATIENT" ]] || die "patient:$PATIENT is not a patient"
            cd "$PATIENT" || die "Unable to acces $GIT_OMMIX_REPO_DIR/$PATIENT !
Please check your permissions"
            ;;&
        sample)
            add_sample ;;

        data|result)
            [[ "$SAMPLE" ]] || die "Please provide a --sample"
            [[ `git rev-parse --verify "sample|$SAMPLE"` ]] || die "sample:$SAMPLE is not a sample of patient:$PATIENT" && dbg stash git checkout "sample|$SAMPLE"
            [[ "$OBJECT" != "result" ]] || [[ "${#USE[@]}" -gt 0 ]] || die "Please --use data when adding a result"
            [[ "${#FILES[@]}" -gt 0 ]] || die "Please provide files to add"
            for ((i = 0; i < ${#FILES[@]}; i++));do
                FILES[i]="$CURRENT_DIR/${FILES[i]}"
            done

            add_object ;;
        diagnostic)
            [[ "${#USE[@]}" -gt 0 ]] || die "Please --use result|diagnostic when adding a diagnostic"
            add_diagnostic ;;

        *)
            usage add ;;
    esac

    commit

    echo "Added $OBJECT:$ID"
}

###############################################################################
#
# List functions

# List patients
# Uses : nothing
function list_patient
{
    # TODO: check if each is a git ommix repo
    ls * --directory -1
}

# List samples
# Uses :
# - PATIENT
function list_sample
{
    git branch --all --list 'sample|*' --format='%(refname:short)'
}

# List data
# Uses :
# - PATIENT
# - SAMPLE
function list_data
{
    git log --pretty=%s | grep --fixed-strings 'data:'
}

# List results
# Uses :
# - PATIENT
# - SAMPLE
function list_result
{
    git log --pretty=%s | grep --fixed-strings 'result:'
}

# List
function list
{
    case "$OBJECT" in
        patient|patients)
            list_patient ;;

        *) # All next operations need a patient, continue matching
            [[ "$PATIENT" ]] || die "Please provide a --patient"
            [[ -d "$PATIENT" ]] || die "patient:$PATIENT is not a patient"
            cd "$PATIENT" || die "Unable to acces the patient directory at: $GIT_OMMIX_REPO_DIR/$PATIENT
Please check your permissions"
            ;;&
        sample|samples)
            list_sample ;;
        diagnostic|diagnostics)
            list_diagnostic ;;

        *) # All next operations need a sample, continue matching
            [[ "$SAMPLE" ]] || die "Please provide a --sample"
            [[ `git rev-parse --verify "sample|$SAMPLE"` ]] || die "sample:$SAMPLE is not a sample of patient:$PATIENT" && dbg stash git checkout "sample|$SAMPLE"
            ;;&
        data)
            list_data ;;
        result|results)
            list_result ;;

        * )
            usage list ;;
    esac
}

# Validate a commit given by its hash or id. It must match a type.
# Return the full name of the object
# $1 : type
# $2 : hash|id
# $3 : t to return hash instead of fullname
function validate_commit
{
    local hash
    local fullname

    # look within the commits of the given type in the current branch
    if git log --oneline | grep -E "$1:$2" --quiet;then
        hash=$(git log --oneline | grep -E "$1:$2" | cut -f 1 -d ' ')
        fullname=$(git log "$hash" --pretty=%s --max-count=1)
    # FIXME: ? dbg does not work as intended, must redirect manually to /dev/null ?
    elif dbg git log "$2";then # find commit by its hash
        fullname=$(git log "$2" --pretty=%s --max-count=1)
        # check that the commit matches the given type
        [[ ${fullname%%:*} =~ "$1" ]] || die "$2 is not the commit hash of existing $1 in sample:$SAMPLE of patient:$PATIENT"
    else
        die "$2 is not the commit hash or the name of existing $1 in sample:$SAMPLE of patient:$PATIENT"
    fi

    if (( $# > 2 )) && echo "$hash" || echo "$fullname"
}

###############################################################################
# Helpers

# Prepare the base components of the PROV message
function base_prov
{
    MESSAGE_ACTIVITY=

    MESSAGE_AGENT="
:provider:$PROVIDER a prov:Agent ."

    MESSAGE_ENTITY="
:$OBJECT:$ID a prov:Entity .
:$OBJECT:$ID prov:wasAttributedTo :provider:$PROVIDER .
:$OBJECT:$ID prov:generatedAtTime xsd:dateTime:$DATE ."

    # Add a method PROV triplets if given
    if [[ "$METHOD" ]];then
        MESSAGE_ACTIVITY="
:method:$METHOD a prov:Activity .
:method:$METHOD startedAtTime xsd:dateTime:$DATE .
:method:$METHOD prov:wasAssociatedWith :provider:$PROVIDER ."

        MESSAGE_ENTITY+="
:$OBJECT:$ID prov:wasGeneratedBy :method:$METHOD ."
    fi
}

# Do the actual git commit with all the parameters set
function commit
{
    dbg git commit --allow-empty \
        --author "$PROVIDER" \
        --date "$DATE" \
        --message "$OBJECT:$ID
$MESSAGE_ENTITY
$MESSAGE_AGENT
$MESSAGE_ACTIVITY
$MESSAGE2"
}

# Validate and add relevant triplets for wasRevisionOf
# An $OBJECT can only be a revision_of another $OBJECT
function revision_of
{
    # TODO: automatically set a REVISION_OF if modified files from a single commit
    # TODO: find commit directly? What for?
    # -> get the used data for a revision of a result
    # but not necessary, just skip the USE and don't require it…
    # if [[ -z "$REVISION_OF" && `git status --porcelain | grep ^M --quiet` ]];then
    #     local revs=()
    #     git status --porcelain | grep ^M | \
    #         (while read line;do
    #              revs+=`git log --pretty=%s --follow --diff-filter=A ${line:3}`
    #          done)
    #     revs=($(printf "%q\n" "${revs[@]}" | sort -u))

    #     if [[ "${#revs}" -gt 1 ]];then
    #         git reset --hard
    #         die "The added $OBJECT would be a revision of two $OBJECT objects"
    #     fi

    #     REVISION_OF="$revs"
    # fi

    REVISION_OF=$(validate_commit "$OBJECT" "$REVISION_OF")

    MESSAGE_ENTITY+="
:$OBJECT:$ID prov:wasRevisionOf :$REVISION_OF ."
}

# Validate and add relevant triplets for wasInvalidated
# TODO: for all invalidated, add invalidatedAtTime ?
function invalidate
{
    local inval
    for inval in "${INVALIDATE[@]}";do
        # TODO: update values in INVALIDATE
        inval=$(validate_commit "$OBJECT" "$inval")

        MESSAGE_ENTITY+="
:$inval prov:wasInvalidatedBy :method:$METHOD ."
    done
}

# Validate and add relevant triplets for wasDerivedFrom
# $1 : type
function use
{
    local use
    # TODO: update values in USE
    for use in "${USE[@]}";do
        use=$(validate_commit "$1" "$use" )

        MESSAGE_ENTITY +="
:$OBJECT:$ID prov:wasDerivedFrom :$use ."

        if [[ "$METHOD" ]];then
            MESSAGE_ACTIVITY +="
:method:$METHOD used :$use ."
        fi
    done
}

###############################################################################
#
# Old functions to rework

# Return the provenance in turtle format
# It is the concatenation of all commit messages (without the subject line)
function prov_all
{
    echo "@prefix xsd:  <http://www.w3.org/2001/XMLSchema#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix prov: <http://www.w3.org/ns/prov#> .
@prefix :     <http://gitommix.org/gitommix#> .
"
    git log --pretty=format:'# %s%n%b' --author-date-order --reverse
}

# Get up-to-date result of a sample
# Print the last commit
function last
{
    git log -n 1 --pretty="format:%s"
}

## Completions
function _completions
{
    #COMP_WORDS = array of words typed after the name of the program
    #COMP_CWORD = index pointing to the word the cursor is at
    #COMP_LINE = the current command line
    if [[ $COMP_CWORD -eq 1 ]];then
        OPTIONS="add invalidate revise query"
    elif [[ $COMP_CWORD -eq 2 ]];then
        case ${COMP_WORDS[1]} in
            query) OPTIONS="list prov";;
        esac
    elif [[ $COMP_CWORD -gt 2 ]];then
        PREV=${COMP_WORDS[$((COMP_CWORD-1))]}
        case $PREV in
            -p|--patient) OPTIONS="$(ls ~/GitOmmix/)";;
            -s|--sample) OPTIONS="sample1 sample2";;
            -D|--date) OPTIONS="$(date +%Y-%m-%d)";;
            -P|--provider) OPTIONS="provider1 provider2";;
            *) OPTIONS="-p --patient -s --sample -D --date -P --provider -m --message -d --debug $(ls)";;
        esac
    fi

    COMPREPLY=`compgen -W "$OPTIONS" -- "${COMP_WORDS[$COMP_CWORD]}"`
}


complete -F _completions git-ommix
