#!/bin/bash

# © Copyright 2024 Maxime Wack
# This file is part of git ommix.

# Git ommix is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

# Git ommix is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

# You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.

###############################################################################
#
# Add functions

# Add dispatch
function add
{
    echo -e "\033[0;32mAdding $OBJECT:$ID\033[0m"

    base_prov

    case "$OBJECT" in
        patient)
            add_patient ;;

        sample)
            validate_patient

            add_sample ;;

        data)
            validate_patient
            validate_sample
            validate_files

            add_data ;;

        result)
            validate_patient
            validate_sample
            validate_files

            # TODO: marche aussi avec juste un revision_of sans sample ?
            # A result object needs to USE a data object
            [[ "${#USE[@]}" -gt 0 ]] || die "Please --use data when adding a result"

            add_result ;;

        diagnostic)
            validate_patient

            # A diagnostic needs to be at least revision_of another diagnostic, or use results or diagnostics,
            [[ "${#USE[@]}" -gt 0 ]] || [[ "$REVISION_OF" ]] || die "Please --use result|diagnostic or --revision_of diagnostic when adding a diagnostic"

            add_diagnostic ;;

        *) usage $VERB ;;
    esac

    commit

    echo -e "\033[0;32mAdded $OBJECT:$ID\033[0m
"
}

# Add patient
# Uses :
# - ID
function add_patient
{
    # Create the patient repo dir and data and result subdirs
    dbg mkdir --parents "$ID/data" || die "Unable to create a directory in the git ommix base directory at: $GIT_OMMIX_REPO_DIR
Please check your permissions"
    dbg mkdir --parents "$ID/result"
    dbg touch "$ID/data/.empty"
    dbg touch "$ID/result/.empty"

    # Go to the patient repo
    dbg cd "$ID"

    # Init git, git annex
    dbg git init
    dbg git annex init

    # Set some default options :
    # - make `cat` the default pager makes it easier to parse outputs
    # - set rule for annex usage
    dbg git config core.pager cat
    dbg git config annex.largefiles "$GIT_OMMIX_LARGE_FILES"
    dbg git config advice.detachedHead false

    # Rename the default branch to the patient ID
    dbg git checkout -b "patient|$ID"

    dbg git add *
}

# Add sample
# Uses :
# - ID
# - PATIENT
function add_sample
{
    # A sample always derives from the patient
    MESSAGE_ENTITY+="
:$OBJECT:$ID prov:wasDerivedFrom :patient:$PATIENT ."

    if [[ "$METHOD" ]];then
        MESSAGE_ACTIVITY+="
:method:$METHOD prov:used :patient:$PATIENT ."
    fi

    # Create a new sample branch stemming from the patient branch
    dbg stash git checkout -b "sample|$ID" "patient|$PATIENT" || die "Sample already exists"
}

# Add data
# Uses :
# - PATIENT
# - SAMPLE
# - [ID]
# - [REVISION_OF data:<id> | <data_hash>]
# - [INVALIDATE data:<id> | <data_hash>] * n
function add_data
{
    # Data always derives from the sample
    MESSAGE_ENTITY+="
:$OBJECT:$ID prov:wasDerivedFrom :sample:$SAMPLE ."

    if [[ "$METHOD" ]];then
        MESSAGE_ACTIVITY+="
:method:$METHOD prov:used :sample:$SAMPLE ."
    fi

    # REVISION_OF
    [[ "$REVISION_OF" ]] && revision_of

    # INVALIDATEs
    [[ "${#INVALIDATE[@]}" -gt 0 ]] && invalidate

    # Copy all the given files to the $OBJECT folder recursively
    # FILES is unquoted to allow * expansion
    dbg cp -t "$GIT_OMMIX_REPO_DIR/$PATIENT/$OBJECT" ${FILES[@]} --recursive || die "Unable to copy files to the patient directory at: $GIT_OMMIX_REPO_DIR/$PATIENT/$OBJECT
Please check your permissions"

    # Add the $OBJECT folder to git
    dbg git add "$OBJECT"
}

# Add result
# Uses :
# - PATIENT
# - SAMPLE
# - USE data:<id> | <data_hash> * n
# - [ID]
# - [REVISION_OF result:<id> | <result_hash>]
# - [INVALIDATE result:<id> | <result_hash>] * n
function add_result
{
    # USE
    use data

    # REVISION_OF
    [[ "$REVISION_OF" ]] && revision_of

    # INVALIDATEs
    [[ "${#INVALIDATE[@]}" -gt 0 ]] && invalidate

    # Copy all the given files to the $OBJECT folder recursively
    # FILES is unquoted to allow * expansion
    dbg cp -t "$GIT_OMMIX_REPO_DIR/$PATIENT/$OBJECT" ${FILES[@]} --recursive || die "Unable to copy files to the patient directory at: $GIT_OMMIX_REPO_DIR/$PATIENT/$OBJECT
Please check your permissions"

    # Add the $OBJECT folder to git
    dbg git add "$OBJECT"
}

# Add diagnostic
# Uses :
# - ID
# - PATIENT
# - USE result|diagnostic:<id> | <result|diagnostic_hash>
# - [INVALIDATE diagnostic:<íd> | <diagnostic_hash>]
# - [REVISION_OF diagnostic:<id> | <diagnostic_hash>]
function add_diagnostic
{
    local merges=()

    # USE
    if [[ "${#USE[@]}" -gt 0 ]]; then
        use "(result|diagnostic)"

        # Start merging from the first object used
        dbg stash git checkout "${HASH[0]}"

        merges+=("${HASH[@]}")
    fi

    # REVISION_OF
    if [[ "$REVISION_OF" ]]; then
        revision_of

        # Start merging from the revision_of
        dbg stash git checkout "$HASH"

        # Remove the diagnostic branch if it existed
        dbg git branch -D "diagnostic|${NAME/diagnostic:}"

        merges=("$HASH" "${merges[@]}")
    fi

    dbg git checkout -b "diagnostic|$ID"

    # INVALIDATEs
    if [[ "${#INVALIDATE[@]}" -gt 0 ]]; then
        invalidate

        local inval

        for inval in "${NAME[@]}"; do
            dbg git branch -D "diagnostic|${inval/diagnostic:}"
        done
    fi

    dbg git merge "${merges[@]}" --no-commit
}

###############################################################################
#
# List functions

# List dispatch
function list
{
    case "$OBJECT" in
        patient)
            list_patient ;;

        sample|data|result|diagnostic)
            validate_patient
            validate_hashes
            list_object ;;
        all)
            validate_patient
            validate_hashes
            list_all ;;
        *) usage $VERB ;;
    esac
}

# List patients
# Uses : nothing
function list_patient
{
    local pat
    for pat in *; do
        dbg git -C "$pat" rev-parse && echo "$pat"
    done
}

# List objects
# Uses :
# - PATIENT
# - [HASHES]
function list_object
{
    git log --format=%s --grep="^$OBJECT:" "${HASHES[@]}"
}

function list_all
{
    git log --format=%s --grep='^\(patient\|sample\|data\|result\|diagnostic\)' "${HASHES[@]}"
}

###############################################################################
# Get functions

# Get dispatch
function get
{
    validate_patient

    case "$OBJECT" in
        prov|last|timeline|object|graph|log|file)
            validate_hashes
            get_"$OBJECT" ;;
        sparql)
            HASHES="--all"
            get_sparql ;;
        *) usage $VERB ;;
    esac
}

# Return the provenance in turtle format
# It is the concatenation of all commit messages (without the subject line)
function get_prov
{
    echo "@prefix xsd:  <http://www.w3.org/2001/XMLSchema#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix prov: <http://www.w3.org/ns/prov#> .
@prefix :     <http://gitommix.org/gitommix#> .

    $(git log --format=%b ${HASHES[@]})" | \
        rapper -i turtle - gitommix -eqo turtle
}

function get_graph
{
    QUERY=" CONSTRUCT {?s ?p ?o} WHERE
{
  { # Entities
    ?s ?p ?o .
    ?s a prov:Entity .
    ?o a prov:Entity .
  }
UNION
  { # Providers
    ?s ?p ?o .
    ?o a :provider .
    FILTER (?p = prov:wasAttributedTo)
  }
UNION
  { # Methods
    ?s ?p ?o .
    ?o a :method .
    FILTER (?p = prov:wasGeneratedBy || ?p = prov:wasInvalidatedBy)
  }
UNION
  { # Methods
    ?s ?p ?o .
    ?s a :method .
    FILTER (?p = prov:used)
  }
UNION
  { # Providers with methods
    ?s ?p ?o .
    ?o a :provider .
    FILTER (?p = prov:wasAssociatedWith)
  }
}"
    get_sparql | \
        turtle2dot | \
        sed -E -e 's/rankdir = LR;/rankdir = BT;/' | \
        dot -Tx11
}

function get_timeline
{
    QUERY="CONSTRUCT {?s ?o ?p} WHERE
{?s ?o ?p .
?s a :diagnostic .
?p a :diagnostic}"

    get_sparql | \
        turtle2dottime | \
        sed -E -e 's/rankdir = LR;/rankdir = RL;/' | \
        dot -Tx11
}

function get_object
{
    git checkout "${HASHES[0]}"
}

# Get up-to-date result of a sample
# Print the last commit
function get_last
{
    git branch --list 'diagnostic|*' --list 'sample|*' --format='%(subject)' --contains "${HASHES[@]}"
}

# Print git commit log
function get_log
{
    git log --oneline --graph "${HASHES[@]}"
}

# Print the name of the files added by the objects
function get_file
{
    git diff-tree --no-commit-id --name-only "${HASHES[@]}" -r
}

function get_sparql
{
    local prefix=$(get_prov | grep "^@prefix" | sed -E -e 's/@//' -e 's/ .$//')
    get_prov | \
        roqet -e "$prefix
$QUERY" -D - -r turtle -q
}

function turtle2dottime
{
    local HEADS=
    for branch in $(git for-each-ref --format='%(refname)' 'refs/heads/diagnostic|*'); do
        HEADS="$HEADS|$(git log --format=%s -1 $branch)"
    done
    HEADS="-e s/(^\t\"R(${HEADS:1})\" \[[^]]+)/\1, color = black, style = \"bold, filled\"/"

    local INVALIDATED=
    for invalid in $(git log --format=%b | grep invalidatedAtTime | cut -f 1 -d ' ');do
        INVALIDATED="$INVALIDATED|${invalid:1}"
    done
    INVALIDATED="-e s/(^\t\"R(${INVALIDATED:1})\" \[[^]]+)/\1, style = \"dashed, filled\"/"

    rapper -i turtle - gitommix -eqo dot | \
        sed -E \
            -e 's/(charset="utf-8";)/\1\n\tnode [ shape = ellipse, color = "#808080", style = filled, fillcolor = white ];/' \
            -e 's/, shape = ellipse, color = blue//' \
            -e 's/label="\w+:/label="/' \
            -e 's/wasDerivedFrom//' \
            -e 's/(label="wasRevisionOf")/label="", weight = 2, style = dashed/' \
            -e 's/(^\t"Rdiagnostic:[^"]+" \[[^]]+)/\1, fillcolor = "#FF9999", group = diagnostics/' \
            $HEADS \
            $INVALIDATED \
            -e 's/(^\t"Rdiagnostic:[^"]+") -> ("Rdiagnostic:[^"]+")/\1:w -> \2:e/' \
            -e 's/^\tlabel=.*//'
}

function turtle2dot
{
    local HEADS=
    for branch in $(git for-each-ref --format='%(refname)' 'refs/heads/patient|*' 'refs/heads/sample|*' 'refs/heads/diagnostic|*'); do
        HEADS="$HEADS|$(git log --format=%s -1 $branch)"
    done
    HEADS="-e s/(^\t\"R(${HEADS:1})\" \[[^]]+)/\1, color = black, style = \"bold, filled\"/"

    local INVALIDATED=
    for invalid in $(git log --format=%b | grep invalidatedAtTime | cut -f 1 -d ' ');do
        INVALIDATED="$INVALIDATED|${invalid:1}"
    done
    INVALIDATED="-e s/(^\t\"R(${INVALIDATED:1})\" \[[^]]+)/\1, style = \"dashed, filled\"/"

    local GRPS=()
    for group in $(git for-each-ref --format='%(refname:short)' 'refs/heads/sample|*'); do
        local COMMITS=
        for commit in $(git log --format=%s $group --invert-grep --grep '^patient'); do
            COMMITS="$COMMITS|$commit"
        done
        GRPS+=("-e s/(^\t\"R(${COMMITS:1})\" \[[^]]+)/\1, group = \"$group\"/")
    done

    rapper -i turtle - gitommix -eqo dot | \
        sed -E \
            -e 's/(charset="utf-8";)/\1\n\tnode [ shape = ellipse, color = "#808080", style = filled, fillcolor = white ];/' \
            -e 's/, shape = ellipse, color = blue//' \
            -e 's/label="\w+:/label="/' \
            -e 's/wasDerivedFrom//' \
            -e 's/(label="wasRevisionOf")/label="", weight = 2, style = dashed/' \
            -e 's/(label="(wasGeneratedBy|used|wasAttributedTo|wasAssociatedWith)")/label="", weight = 0, color=gray/' \
            -e 's/(^\t"Rdata:[^"]+" \[[^]]+)/\1, fillcolor = "#9999FF"/' \
            -e 's/(^\t"Rresult:[^"]+" \[[^]]+)/\1, fillcolor = "#99FF99"/' \
            -e 's/(^\t"Rdiagnostic:[^"]+" \[[^]]+)/\1, fillcolor = "#FF9999", group = diagnostics/' \
            ${GRPS[@]} \
            $HEADS \
            $INVALIDATED \
            -e 's/(^\t"Rmethod:[^"]+" \[[^]]+)/\1, shape = rectangle, color = blue, fillcolor = "#9FB1FC"/' \
            -e 's/(^\t"Rprovider:[^"]+" \[[^]]+)/\1, shape = house, color = black, fillcolor = "#FED37F"/' \
            -e 's/(^\t"Rdata:[^"]+" -> "Rsample:[^]]+)/\1, weight = 5/' \
            -e 's/(^\t"Rsample:[^"]+" -> "Rpatient:[^]]+)/\1, weight = 5/' \
            -e 's/(^\t"Rdiagnostic:[^"]+" -> "Rresult:[^]]+)/\1, minlen = 3/' \
            -e 's/(^\t"Rdata:[^"]+") -> ("Rsample:[^"]+")/\1:n -> \2:s/' \
            -e 's/(^\t"Rresult:[^"]+") -> ("Rdata:[^"]+")/\1:n -> \2:s/' \
            -e 's/(^\t"Rdiagnostic:[^"]+") -> ("Rdiagnostic:[^"]+")/\1:n -> \2:s/' \
            -e 's/(^\t"Rdiagnostic:[^"]+") -> ("Rresult:[^"]+")/\1 -> \2:s/' \
            -e 's/(^\t"Rsample:[^"]+") -> ("Rpatient:[^"]+")/\1:n -> \2/' \
            -e 's/^\tlabel=.*//'
}

###############################################################################
#
# Validation helpers

# Validate PATIENT and switch to it
function validate_patient
{
    [[ "$PATIENT" ]] || die "Please provide a --patient"
    dbg git -C "$PATIENT" rev-parse || die "patient:$PATIENT is not a patient"
    cd "$PATIENT" || die "Unable to acces the patient directory at: $GIT_OMMIX_REPO_DIR/$PATIENT
Please check your permissions"
}

# Validate SAMPLE and switch to it
function validate_sample
{
    [[ "$SAMPLE" ]] || die "Please provide a --sample"
    dbg git rev-parse --verify "sample|$SAMPLE" || die "sample:$SAMPLE is not a sample of patient:$PATIENT"
    dbg stash git checkout "sample|$SAMPLE" || die "Something wrong happened, unable to checkout sample|$SAMPLE of patient:$PATIENT"
}

# Validate FILES and qualify path
function validate_files
{
    [[ "${#FILES[@]}" -gt 0 ]] || die "Please provide files to add"
    # Qualify FILES with their full path
    for ((i = 0; i < ${#FILES[@]}; i++));do
        FILES[i]="$CURRENT_DIR/${FILES[i]}"
    done
}

# Validate a commit given by its hash or id. It must match a type.
# Return the full name of the object
# $1 : type
# $2 : hash|id
function validate_commit
{
    # Remove prefix from names given in full
    HASH="$2"
    NAME="$(echo "$2" | sed -r "s/^$1://")"

    # find commit by its id, matching the type in $1
    if git log --format="%s" --all | grep -E "^$1:$NAME$" --quiet;then
        HASH="$(git log --format="%h %s" --all | grep -E "\b$1:$NAME$" | cut -d ' ' -f 1)"
        NAME="$(git log --format=%s --max-count=1 "$HASH")"
    elif dbg git log "$HASH";then # find commit by its hash
        NAME="$(git log --format=%s --max-count=1 "$HASH")"
        # check that the commit matches the given type in $1
        echo "$NAME" | grep -E "^$1:" --quiet || die "$HASH is not the commit hash of existing $1 of patient:$PATIENT"
    else
        die "$2 is neither the commit hash nor the name of existing $1 of patient:$PATIENT"
    fi
}

# Validate hashes or resolve and expand names given after a list verb
function validate_hashes
{
    local hash
    local out=()

    if [[ "${#HASHES[@]}" -gt 0 ]];then
        for hash in "${HASHES[@]}";do
            if git log --format="%s" --all | grep -E "$hash$" --quiet;then
                out+=($(git log --format="%h %s" --all | grep -E "$hash$" | cut -d ' ' -f 1))
            elif dbg git log "$hash";then
                out+=("$(git log --format=%h --max-count=1 "$hash")")
            else
                die "$hash is neither the commit hash nor the name of an existing object of patient:$PATIENT"
            fi
        done
        HASHES=("${out[@]}")
    else
        HASHES="--all"
    fi
}

###############################################################################
# PROV Helpers

# Prepare the base components of the PROV message
function base_prov
{
    MESSAGE_ACTIVITY=
    MESSAGE_AGENT=
    MESSAGE_ENTITY="
:$OBJECT:$ID prov:generatedAtTime xsd:dateTime:$DATE .
:$OBJECT:$ID a prov:Entity .
:$OBJECT:$ID a :$OBJECT .
:$OBJECT:$ID foaf:name \"$ID\" ."

    if [[ "$PROVIDER" ]];then
        MESSAGE_AGENT+="
:provider:$PROVIDER a prov:Agent .
:provider:$PROVIDER a :provider ."
        MESSAGE_ENTITY+="
:$OBJECT:$ID prov:wasAttributedTo :provider:$PROVIDER ."
    fi

    # Add a method PROV triplets if given
    if [[ "$METHOD" ]];then
        MESSAGE_ACTIVITY="
:method:$METHOD a prov:Activity .
:method:$METHOD a :method .
:method:$METHOD prov:startedAtTime xsd:dateTime:$DATE ."

        if [[ "$PROVIDER" ]];then
            MESSAGE_ACTIVITY+="
:method:$METHOD prov:wasAssociatedWith :provider:$PROVIDER ."
        fi

        MESSAGE_ENTITY+="
:$OBJECT:$ID prov:wasGeneratedBy :method:$METHOD ."
    fi
}

# Validate and add relevant triplets for wasRevisionOf
# An $OBJECT can only be a revision_of another $OBJECT
function revision_of
{
    validate_commit "$OBJECT" "$REVISION_OF"

    MESSAGE_ENTITY+="
:$OBJECT:$ID prov:wasRevisionOf :$NAME ."
}

# Validate and add relevant triplets for wasInvalidated
function invalidate
{
    local inval
    local out_hash=()
    local out_name=()

    for inval in "${INVALIDATE[@]}";do
        validate_commit "$OBJECT" "$inval"
        out_hash+=("$HASH")
        out_name+=("$NAME")

        MESSAGE_ENTITY+="
:$NAME prov:invalidatedAtTime xsd:dateTime:$DATE ."

        if [[ "$METHOD" ]];then
            MESSAGE_ENTITY+="
:$NAME prov:wasInvalidatedBy :method:$METHOD ."
        fi
    done

    HASH=("${out_hash[@]}")
    NAME=("${out_name[@]}")
}

# Validate and add relevant triplets for wasDerivedFrom
# $1 : type
function use
{
    local use
    local out_hash=()
    local out_name=()

    for use in "${USE[@]}";do
        validate_commit "$1" "$use"
        out_hash+=("$HASH")
        out_name+=("$NAME")

        MESSAGE_ENTITY+="
:$OBJECT:$ID prov:wasDerivedFrom :$NAME ."

        if [[ "$METHOD" ]];then
            MESSAGE_ACTIVITY+="
:method:$METHOD prov:used :$NAME ."
        fi
    done

    HASH=("${out_hash[@]}")
    NAME=("${out_name[@]}")
}

# Do the actual git commit with all the parameters set
function commit
{
    dbg git commit --allow-empty \
        --author "$AUTHOR" \
        --date "$DATE" \
        --message "$OBJECT:$ID
$MESSAGE_ENTITY
$MESSAGE_AGENT
$MESSAGE_ACTIVITY
$MESSAGE2"

    dbg git annex restage
}

###############################################################################
#
# Utility functions

# Print messages passed as arguments and exit in error
function die
{
    echo -e "\033[0;31m$@\033[0m"
    exit 2
}

# Redirect commands to &>/dev/null if not DEBUGging
function dbg
{
    if [[ "$DEBUG" == "debug" ]]; then
        echo -ne "\033[0;30m"
        "$@"
        echo -ne "\033[0m"
    elif [[ "$DEBUG" == "dry" ]];then
        echo -e "\033[0;34m$@\033[0m"
    elif [[ "$DEBUG" == "verbose" ]];then
        echo -e "\033[0;34m$@\033[0m"
        echo -ne "\033[0;30m"
        "$@"
        echo -ne "\033[0m"
    else
        "$@" &>/dev/null
    fi
}

# Stash in place modifications
function stash
{
    git stash push
    "$@"
    git stash pop
}

###############################################################################
#
# Usage

function usage
{
    case "$1" in
        root) 
            echo "git ommix {verb} {object} [--options] [files]

Verbs:
- add
- list
- get

Type \"git ommix {verb}\" to get help on {verb}

Debugging options:

-d|--debug : print the raw command output
--dry : print instead of running any write command
--verbose : print and run write commands

Git ommix can be configured system-wide with /etc/gitommix.conf,
per user with \$XDG_CONFIG/.gitommix
or with environment variables:

- GIT_OMMIX_REPO_DIR : place to find patient repos (default: ~/GitOmmix/)
- GIT_OMMIX_LARGE_FILES : git ommix rules for large files (default: largerthan=100Mb and (include=data/* or include=results/*))
- GIT_OMMIX_DEFAULT_AUTHOR : set a default commit author (default: gitommix <gitommix>)" ;;
        add)
            echo "git ommix add <object> [--options] [--message] [FILES]

Add a new instance of an object.
Various options can be associated with an object (id, provider, method, etc.).
Some options are mandatory depending on the added object.
Anything other than a new patient has to be associated to a patient.
Data and results are associated to samples.
Results use data.
Diagnoses use results and other diagnoses.
Data and results add [FILES] to the repo into the respective directory. 
If [FILES] is not specified, all the files in the current directory are added to the data/result.

Objects:
- patient
- sample     -p <patient>
- data       -p <patient> -s <sample>
- result     -p <patient> -s <sample> --use <data>
- diagnostic -p <patient> --use <result|diagnostic>

Options:
--id (-i) (default: randomly generated string)
--patient (-p)
--sample (-s)
--method
--date (default: current date)
--provider
--use
--revision_of
--invalidate

Data, results, and diagnoses can be a revision_of and/or invalidate another object of the same type.

Additional PROV triples further qualifying the objects can be added in the turtle format using --message" ;;
        list)
            echo "git ommix list {object} -p <patient> [<object>...]

List all the objects of the given type in the given patient, optionally constrained to the history of one or multiple objects.

Objects:
- patient
- sample
- data
- result
- diagnostic

Optional reference objects can be specified as commit hashes, the full name of the object, or only the name part of the object, matching all the objects with the same name." ;;
        get)
            echo "git ommix get {option} -p <patient> [<object>...]

Run queries on the patient's git ommix store, optionally constrained to the history of one or multiple objects.

- prov: get the PROV in turtle format
- graph: get a graphical representation of the PROV
- last: get the last version of an object
- timeline: get a timeline of diagnoses
- object: checkout the patient repo at the time of the addition of the object
- log: get the git log of the repo
- file: get the list of files added by an object
- sparql: execute an arbitrary SPARQL query" ;;
    esac
    exit 0
}
