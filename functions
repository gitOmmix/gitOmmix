#!/bin/bash

# usage function
function usage
{
    case "$1" in
        root) 
            echo "git ommix {verb} {object} [--options] [files]

Verbs:
- add
- list
- get

Objects:
- patient
- sample
- data
- result
- diagnostic

Options:
- --id/-i : object id (default = random base64 10 chars)
- --date/-D : sampling/analysis date (default = current date)
- --provider/-P : data/result provider (default = current user)
- --patient/-p : patient (default = current patient)
- --sample/-s : sample (default = current sample)
- --message/-m : add an arbitrary PROV-O RDF triplet to the transaction
- --debug/-d : debug

Files: files to add (default = all new/modified files)

Register bash completions with register completions

Git ommix can be configured with the \$XDG_CONFIG/.gitommix file, or with environment variables

Available options are:
- GIT_OMMIX_REPO_DIR : place to find patient repos
"
            ;;
        add)
            echo "git ommix add {patient, sample, data, result, diagnostic} [--options] [--message]

# Patient 

Create patient repo with the given id.
Options :

-i <id>

# Sample

Create the branch with the given sample id for the current or selected patient.

Options :

 -i <id>
 -p <patient>

# Data 

Add the FILES to data, with the given id, for the current or selected sample in the current or selected patient.
Data are always DERIVED_FROM the sample, but could be also be a REVISION_OF previous data. This can be set by pointing to a data commit to revise.
The data that has been revised can also be INVALIDATEd at the same time.

Options :

-i <id>
-p <patient>
-s <sample>
[--revision_of <data_hash>]
[--invalidate]

# Result 

Options :

-i <id> 
-p <patient> 
-s <sample> 
--use <data_hash> 
[--revision_of <result_hash>]
[--invalidate]

# Diagnostic

Add a diagnostic with the given id, for the current or selected patient.
The diagnostic can USE multiple results and diagnostics, be the REVISION_OF multiple diagnostics, which can be INVALIDATEd at the same time.
The diagnostic branch pointers for the revised diagnostics are destroyed.

Options :

-i <id>
-p <patient>
--use <result/diagnostic_hash>
[--revision_of <diagnostic_hash>]
[--invalidate]

Add data/result to the current patient and sample if inside a repo, or to the --patient and --sample specified.
If stateless, copy the files to the repo."
            ;;
    esac
    exit 0
}

# Print messages passed as arguments and exit in error
function die
{
    echo $@
    exit 1
}

# Redirect commands to &>/dev/null if not DEBUGging
function dbg
{
    if [[ "$DEBUG" == "debug" ]]; then
        "$@"
    elif [[ "$DEBUG" == "dry" ]];then
        echo "$@"
    else
        "$@" &>/dev/null
    fi
}

# Stash in place modifications
function stash
{
    git stash push
    "$@"
    git stash pop
}

# Add patient
# Uses :
# - ID
function add_patient
{
    # Create the patient repo dir and data and result subdirs
    dbg mkdir --parents "$ID/data"
    dbg mkdir --parents "$ID/result"

    # Go to the patient repo
    dbg cd "$ID"

    # Init git, git annex
    dbg git init
    dbg git annex init

    # Set some default options :
    # - make `cat` the default pager makes it easier to parse outputs
    # - set rule for annex usage
    dbg git config core.pager cat
    dbg git config annex.largefiles "$GIT_OMMIX_LARGE_FILES"

    # Rename the default branch to the patient ID
    dbg git checkout -b "patient|$ID"

    # Create an empty commit with the PROV message
    dbg git commit --allow-empty \
        --author "$PROVIDER" \
        --date "$DATE" \
        --message "patient:$ID

patient:$ID a prov:Entity .
patient:$ID a MSH:Patient .
$MESSAGE2"
}

# Add sample
# Uses :
# - ID
# - PATIENT
function add_sample
{
    # Create a new sample branch stemming from the patient branch
    dbg stash git checkout -b "sample|$ID" "patient|$PATIENT"

    # Build the PROV message
    MESSAGE="sample:$ID

provider:$PROVIDER a prov:Agent .

sample:$ID a prov:Entity .
sample:$ID wasDerivedFrom patient:$PATIENT .
sample:$ID wasAttributedTo provider:$PROVIDER .
sample:$ID generatedAtTime xsd:dateTime:$DATE .
"

    # Add a method PROV triplets if given
    if [[ "$METHOD" ]];then
        MESSAGE+="sample:$ID wasGeneratedBy method:$METHOD .

method:$METHOD a prov:Activity .
method:$METHOD used patient:$PATIENT .
method:$METHOD wasAssociatedWith provider:$PROVIDER .
"
    fi

    # Create an empty commit with the PROV message
    dbg git commit --allow-empty \
        --author "$PROVIDER" \
        --date "$DATE" \
        --message "$MESSAGE
$MESSAGE2"
}

# Add data|result
# Uses :
# - ID
# - PATIENT
# - SAMPLE
# - [USE data:<id> | <data_hash>] * n
# - [REVISION_OF data|result:<id> | <data|result_hash>]
# - [INVALIDATE data|result:<id> | <data|result_hash>] * n
function add_object
{
    # Copy all the given files to the $OBJECT folder recursively
    dbg cp "$CURRENT_DIR/"$FILES "$GIT_OMMIX_REPO_DIR/$PATIENT/$OBJECT" --recursive

    # Add the $OBJECT folder to git
    dbg git add "$OBJECT"

    # TODO: detect if modified $OBJECT -> revision_of
    #find commit directly?
    if `git status --porcelain | grep ^M --quiet`;then
        git status --porcelain | grep ^M | \
            (while read line;do
                 REVISION_OF=`git log --pretty=%s --follow --diff-filter=A ${line:3}`
             done)
    fi

    if [[ "$OBJECT" == "data" ]];then
        # data always derives from the sample
        PROV_DERIVE="$OBJECT:$ID wasDerivedFrom sample:$SAMPLE ."
        PROV_USE="method:$METHOD used sample:$SAMPLE ."
    else
        for use in "${USE[@]}";do
            # accept data:id (as is) or commit hash (translated to data:id)
            if [[ "${use%%:*}" != "data" ]];then
                if `dbg git log "$use" --pretty=%s --max-count=1`;then
                    use=`git log "$use" --pretty=%s --max-count=1`
                else
                    die "$use is not the commit hash or the name of existing data in sample:$SAMPLE of patient:$PATIENT"
                fi
            fi

            # check if existing data for this sample
            if ! `git log --oneline | grep --fixed-strings "$use" --quiet`;then
                die "$use is not the name of existing data in sample:$SAMPLE of patient:$PATIENT"
            fi

            PROV_DERIVE+="$OBJECT:$ID wasDerivedFrom $use .
"
            PROV_USE+="method:$METHOD used $use .
"
        done
    fi

    # Build the PROV message
    # TODO: wasRevisionOf should replace wasDerivedFrom
    MESSAGE="$OBJECT:$ID

$OBJECT:$ID a prov:Entity .
$PROV_DERIVE
$OBJECT:$ID wasAttributedTo provider:$PROVIDER .
$OBJECT:$ID generatedAtTime xsd:dateTime:$DATE .
"

    # If the $OBJECT is a REVISION_OF
    if [[ "$REVISION_OF" ]];then
        # accept $OBJECT:id (as is) or commit hash (translated to $OBJECT:id)
        if [[ "${REVISION_OF%%:*}" != "$OBJECT" ]];then
            if `dbg git log "$REVISION_OF" --pretty=%s --max-count=1`;then
                REVISION_OF=`git log "$REVISION_OF" --pretty=%s --max-count=1`
            else
                die "$REVISION_OF is not the commit hash or the name of existing $OBJECT in sample:$SAMPLE of patient:$PATIENT"
            fi
        fi

        # check if existing $OBJECT for this sample
        if `git log --oneline | grep --fixed-strings "$REVISION_OF" --quiet`;then
            MESSAGE+="$OBJECT:$ID wasRevisionOf $REVISION_OF .
"
        else
            die "$REVISION_OF is not the name of existing $OBJECT in sample:$SAMPLE of patient:$PATIENT"
        fi
    fi

    # If the $OBJECT INVALIDATEs one or more previous $OBJECT commit(s)
    if [[ "${#INVALIDATE[@]}" -gt 0 && "$METHOD" ]];then
        local inval
        for inval in "${INVALIDATE[@]}";do
            # accept $OBJECT:id (as is) or commit hash (translated to $OBJECT:id)
            if [[ "${inval%%:*}" != "$OBJECT" ]];then
                if `git log "$inval" --pretty=%s --max-count=1`;then
                    inval=`git log "$inval" --pretty=%s --max-count=1`
                else
                    die "$inval is not the commit hash or the name of existing $OBJECT in sample:$SAMPLE of patient:$PATIENT"
                fi
            fi

            # check if existing $OBJECT for this sample
            if `git log --oneline | grep --fixed-strings "$inval" --quiet`;then
                MESSAGE+="$inval wasInvalidatedBy method:$METHOD .
"
            else
                die "$inval is not the name of existing $OBJECT in sample:$SAMPLE of patient:$PATIENT"
            fi
        done
    fi

    # Add a method PROV triplets if given
    if [[ "$METHOD" ]];then
        MESSAGE+="$OBJECT:$ID wasGeneratedBy method:$METHOD .

method:$METHOD a prov:Activity .
$PROV_USE
method:$METHOD startedAtTime xsd:dateTime:$DATE .
method:$METHOD wasAssociatedWith provider:$PROVIDER .
"
    fi

    # Create a commit with the PROV message and the added $OBJECT
    dbg git commit \
        --date "$DATE" \
        --author "$PROVIDER" \
        --message "$MESSAGE
$MESSAGE2"
}

# Add diagnostic
# Uses :
# - ID
# - PATIENT
# - USE result|diagnostic:<id> | <result|diagnostic_hash>
# - [INVALIDATE diagnostic:<íd> | <diagnostic_hash>]
# - [REVISION_OF diagnostic:<id> | <diagnostic_hash>]
function add_diagnostic
{
    # commit on diagnostic branch if revision_of a previous diagnostic else create diagnostic branch
    # can invalidate a diagnostic

    # Check the USEd objects
    # accept result|diagnostic:id (as is) or commit hash (translated to result|diagnostic:id)
    # TODO: deal with arrays
    if [[ "${USE%%:*}" != "result" || "${USE%%:*}" != "diagnostic" ]];then
        if `dbg git log "$USE" --pretty=%s --max-count=1`;then
            USE=`git log "$USE" --pretty=%s --max-count=1`
        else
            die "$USE is not the commit hash or the name of existing result or diagnostic of patient:$PATIENT"
        fi
    fi

    # check if existing $OBJECT for this sample
    if `git log --oneline | grep --fixed-strings "$USE" --quiet`;then
        MESSAGE+="diagnostic:$ID used $USE .
"
    else
        die "$USE is not the name of existing diagnostic of patient:$PATIENT"
    fi

    # Build the PROV message
    # TODO: revision_of should replace wasDerivedFrom
    MESSAGE="$OBJECT:$ID

$OBJECT:$ID a prov:Entity .
$OBJECT:$ID wasDerivedFrom $USE .
$OBJECT:$ID wasAttributedTo provider:$PROVIDER .
$OBJECT:$ID generatedAtTime xsd:dateTime:$DATE .
"

    # If the $OBJECT is a REVISION_OF
    if [[ "$REVISION_OF" ]];then
        # accept diagnostic:id (as is) or commit hash (translated to diagnostic:id)
        if [[ "${REVISION_OF%%:*}" != "diagnostic" ]];then
            if `dbg git log "$REVISION_OF" --pretty=%s --max-count=1`;then
                REVISION_OF=`git log "$REVISION_OF" --pretty=%s --max-count=1`
            else
                die "$REVISION_OF is not the commit hash or the name of existing diagnostic of patient:$PATIENT"
            fi
        fi

        # check if existing diagnostic for this sample
        if `git log --oneline | grep --fixed-strings "$REVISION_OF" --quiet`;then
            MESSAGE+="$OBJECT:$ID wasRevisionOf $REVISION_OF .
"
        else
            die "$REVISION_OF is not the name of existing diagnostic of patient:$PATIENT"
        fi
    fi

    # If the diagnostic INVALIDATEs one or more previous diagnostic commit(s)
    if [[ "${#INVALIDATE[@]}" -gt 0 && "$METHOD" ]];then
        for inval in "${INVALIDATE[@]}";do
            # accept diagnostic:id (as is) or commit hash (translated to diagnostic:id)
            if [[ "${inval%%:*}" != "diagnostic" ]];then
                if `dbg git log "$inval" --pretty=%s --max-count=1`;then
                    inval=`git log "$inval" --pretty=%s --max-count=1`
                else
                    die "$inval is not the commit hash or the name of existing diagnostic of patient:$PATIENT"
                fi
            fi

            # check if existing diagnostic for this sample
            if `git log --oneline | grep --fixed-strings "$inval" --quiet`;then
                MESSAGE+="$inval wasInvalidatedBy method:$METHOD .
"
            else
                die "$inval is not the name of existing diagnostic of patient:$PATIENT"
            fi
        done
    fi

    # Add a method PROV triplets if given
    if [[ "$METHOD" ]];then
        MESSAGE+="$OBJECT:$ID wasGeneratedBy method:$METHOD .

method:$METHOD a prov:Activity .
method:$METHOD used $USE .
method:$METHOD startedAtTime xsd:dateTime:$DATE .
method:$METHOD wasAssociatedWith provider:$PROVIDER .
"
    fi

    # Create a commit with the PROV message and the added $OBJECT
    dbg git commit \
        --date "$DATE" \
        --author "$PROVIDER" \
        -m "$MESSAGE
$MESSAGE2"
}

# Add
function add
{
    echo "Adding $OBJECT:$ID"

    case "$OBJECT" in
        patient)
            add_patient ;;
        sample)
            # A sample needs a patient
            [[ "$PATIENT" ]] || die "Please provide a --patient"

            add_sample ;;
        data|result)
            # Data and results need a patient
            [[ "$PATIENT" ]] || die "Please provide a --patient"

            # Data and results need a sample
            [[ "$SAMPLE" ]] || die "Please provide a --sample"

            # A result needs to use data
            [[ "$OBJECT" == "result" ]] && { [[ "${#USE[@]}" -gt 0 ]] || die "Please --use data when adding a result" ; }

            # if [[ -z "$FILES" ]];then
            #     die "Please provide data files to add"
            # fi

            add_object ;;
        diagnostic)
            # A diagnostic needs a patient
            [[ "$PATIENT" ]] || die "Please provide a --patient"

            # A diagnostic needs to use results or diagonstics
            [[ "$USE" ]] || die "Please --use result|diagnostic when adding a diagnostic"

            add_diagnostic ;;
        *) usage add;;
    esac
}

# List patients
# Uses : nothing
function list_patient
{
    # TODO: check if each is a git ommix repo
    dbg ls * --directory -1
}

# List samples
# Uses :
# - PATIENT
function list_sample
{
    dbg git branch --all | grep "sample|"
}

# List
function list
{
    echo "Listing $OBJECT"

    case "$OBJECT" in
        patient|patients)
            list_patient ;;
        sample|samples)
            [[ "$PATIENT" ]] || die "Please provide a --patient"

            list_sample ;;
        data) ;;
        result|results) ;;
        diagnostic|diagnostics) ;;
        * ) usage list ;;
    esac
}

# Return the provenance in turtle format
# It is the concatenation of all commit messages (without the subject line)
function prov_all
{
    git log --pretty=format:'# %s%n%b' --author-date-order --reverse
}

# Get up-to-date result of a sample
# Print the last commit
function last
{
    git log -n 1 --pretty="format:%s"
}

## Completions
function _completions
{
    #COMP_WORDS = array of words typed after the name of the program
    #COMP_CWORD = index pointing to the word the cursor is at
    #COMP_LINE = the current command line
    if [[ $COMP_CWORD -eq 1 ]];then
        OPTIONS="add invalidate revise query"
    elif [[ $COMP_CWORD -eq 2 ]];then
        case ${COMP_WORDS[1]} in
            query) OPTIONS="list prov";;
        esac
    elif [[ $COMP_CWORD -gt 2 ]];then
        PREV=${COMP_WORDS[$((COMP_CWORD-1))]}
        case $PREV in
            -p|--patient) OPTIONS="$(ls ~/GitOmmix/)";;
            -s|--sample) OPTIONS="sample1 sample2";;
            -D|--date) OPTIONS="$(date +%Y-%m-%d)";;
            -P|--provider) OPTIONS="provider1 provider2";;
            *) OPTIONS="-p --patient -s --sample -D --date -P --provider -m --message -d --debug $(ls)";;
        esac
    fi

    COMPREPLY=`compgen -W "$OPTIONS" -- "${COMP_WORDS[$COMP_CWORD]}"`
}


complete -F _completions git-ommix
