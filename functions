#!/bin/bash

###############################################################################
#
# Usage

function usage
{
    case "$1" in
        root) 
            echo "git ommix {verb} {object} [--options] [files]

Verbs:
- add
- list
- get

Git Ommix options:
- GIT_OMMIX_REPO_DIR : place to find patient repos
- GIT_OMMIX_LARGE_FILES : git ommix rules for large files
- GIT_OMMIX_DEFAULT_PROVIDER : set a default provider

Git ommix can be configured with the \$XDG_CONFIG/.gitommix file, or with environment variables.

Register bash completions with register completions.
" ;;
        add)
            echo "git ommix add {object} [--options] [--message]

Objects:
- patient
- sample
- data
- result
- diagnostic

# Patient 

Create patient repo with the given id.
Options :

 -i <id>

# Sample

Create the branch with the given sample id for the current or selected patient.

Options :

 -i <id>
 -p <patient>

# Data 

Add the FILES to data, with the given id, for the current or selected sample in the current or selected patient.
Data are always DERIVED_FROM the sample, but could be also be a REVISION_OF previous data. This can be set by pointing to a data commit to revise.
The data that has been revised can also be INVALIDATEd at the same time.

Options :

 -i <id>
 -p <patient>
 -s <sample>
 [--revision_of <data_hash>]
 [--invalidate]

# Result 

Options :

 -i <id> 
 -p <patient> 
 -s <sample> 
 --use <data_hash> 
 [--revision_of <result_hash>]
 [--invalidate]

# Diagnostic

Add a diagnostic with the given id, for the current or selected patient.
The diagnostic can USE multiple results and diagnostics, be the REVISION_OF multiple diagnostics, which can be INVALIDATEd at the same time.
The diagnostic branch pointers for the revised diagnostics are destroyed.

Options :

 -i <id>
 -p <patient>
 --use <result/diagnostic_hash>
 [--revision_of <diagnostic_hash>]
 [--invalidate]
" ;;
        list)
            echo "git ommix list {object}

Objects:
- patient(s)
- sample(s)
- data(s)
- result(s)
- diagnostic(s)
" ;;
    esac
    exit 0
}

###############################################################################
#
# Utility functions

# Print messages passed as arguments and exit in error
function die
{
    echo -e "\033[0;31m$@\033[0m"
    exit 2
}

# Redirect commands to &>/dev/null if not DEBUGging
function dbg
{
    if [[ "$DEBUG" == "debug" ]]; then
        echo -ne "\033[0;30m"
        "$@"
        echo -ne "\033[0m"
    elif [[ "$DEBUG" == "dry" ]];then
        echo -e "\033[0;34m$@\033[0m"
    elif [[ "$DEBUG" == "verbose" ]];then
        echo -e "\033[0;34m$@\033[0m"
        echo -ne "\033[0;30m"
        "$@"
        echo -ne "\033[0m"
    else
        "$@" &>/dev/null
    fi
}

# Stash in place modifications
function stash
{
    git stash push
    "$@"
    git stash pop
}

###############################################################################
#
# Add functions

# Add patient
# Uses :
# - ID
function add_patient
{
    # Create the patient repo dir and data and result subdirs
    dbg mkdir --parents "$ID/data" || die "Unable to create a directory in the git ommix base directory at: $GIT_OMMIX_REPO_DIR
Please check your permissions"
    dbg mkdir --parents "$ID/result"
    dbg touch "$ID/data/.empty"
    dbg touch "$ID/result/.empty"

    # Go to the patient repo
    dbg cd "$ID"

    # Init git, git annex
    dbg git init
    dbg git annex init

    # Set some default options :
    # - make `cat` the default pager makes it easier to parse outputs
    # - set rule for annex usage
    dbg git config core.pager cat
    dbg git config annex.largefiles "$GIT_OMMIX_LARGE_FILES"
    dbg git config advice.detachedHead false

    # Rename the default branch to the patient ID
    dbg git checkout -b "patient|$ID"

    dbg git add *
}

# Add sample
# Uses :
# - ID
# - PATIENT
function add_sample
{
    # A sample always derives from the patient
    MESSAGE_ENTITY+="
:$OBJECT:$ID prov:wasDerivedFrom :patient:$PATIENT ."

    if [[ "$METHOD" ]];then
        MESSAGE_ACTIVITY+="
:method:$METHOD used :patient:$PATIENT ."
    fi

    # Create a new sample branch stemming from the patient branch
    dbg stash git checkout -b "sample|$ID" "patient|$PATIENT" || die "Sample already exists"
}

# Add data
# Uses :
# - PATIENT
# - SAMPLE
# - [ID]
# - [REVISION_OF data:<id> | <data_hash>]
# - [INVALIDATE data:<id> | <data_hash>] * n
function add_data
{
    # Data always derives from the sample
    MESSAGE_ENTITY+="
:$OBJECT:$ID prov:wasDerivedFrom :sample:$SAMPLE ."

    if [[ "$METHOD" ]];then
        MESSAGE_ACTIVITY+="
:method:$METHOD used :sample:$SAMPLE ."
    fi

    # REVISION_OF
    [[ "$REVISION_OF" ]] && revision_of

    # INVALIDATEs
    [[ "${#INVALIDATE[@]}" -gt 0 ]] && invalidate

    # Copy all the given files to the $OBJECT folder recursively
    # FILES is unquoted to allow * expansion
    dbg cp -t "$GIT_OMMIX_REPO_DIR/$PATIENT/$OBJECT" ${FILES[@]} --recursive || die "Unable to copy files to the patient directory at: $GIT_OMMIX_REPO_DIR/$PATIENT/$OBJECT
Please check your permissions"

    # Add the $OBJECT folder to git
    dbg git add "$OBJECT"
}

# Add result
# Uses :
# - PATIENT
# - SAMPLE
# - USE data:<id> | <data_hash> * n
# - [ID]
# - [REVISION_OF result:<id> | <result_hash>]
# - [INVALIDATE result:<id> | <result_hash>] * n
function add_result
{
    # USE
    use data

    # REVISION_OF
    [[ "$REVISION_OF" ]] && revision_of

    # INVALIDATEs
    [[ "${#INVALIDATE[@]}" -gt 0 ]] && invalidate

    # Copy all the given files to the $OBJECT folder recursively
    # FILES is unquoted to allow * expansion
    dbg cp -t "$GIT_OMMIX_REPO_DIR/$PATIENT/$OBJECT" ${FILES[@]} --recursive || die "Unable to copy files to the patient directory at: $GIT_OMMIX_REPO_DIR/$PATIENT/$OBJECT
Please check your permissions"

    # Add the $OBJECT folder to git
    dbg git add "$OBJECT"
}

# Add diagnostic
# Uses :
# - ID
# - PATIENT
# - USE result|diagnostic:<id> | <result|diagnostic_hash>
# - [INVALIDATE diagnostic:<íd> | <diagnostic_hash>]
# - [REVISION_OF diagnostic:<id> | <diagnostic_hash>]
function add_diagnostic
{
    local merges=()

    # USE
    if [[ "${#USE[@]}" -gt 0 ]]; then
        use "(result|diagnostic)"

        # Start merging from the first object used
        dbg stash git checkout "${HASH[0]}"

        merges+=("${HASH[@]}")
    fi

    # REVISION_OF
    if [[ "$REVISION_OF" ]]; then
        revision_of

        # Start merging from the revision_of
        dbg stash git checkout "$HASH"

        # Remove the diagnostic branch if it existed
        dbg git branch -D "diagnostic|${NAME/diagnostic:}"

        merges=("$HASH" "${merges[@]}")
    fi

    dbg git checkout -b "diagnostic|$ID"

    # INVALIDATEs
    if [[ "${#INVALIDATE[@]}" -gt 0 ]]; then
        invalidate

        local inval

        for inval in "${NAME[@]}"; do
            dbg git branch -D "diagnostic|${inval/diagnostic:}"
        done
    fi

    dbg git merge "${merges[@]}" --no-commit
}

# Add
function add
{
    base_prov

    case "$OBJECT" in
        patient)
            add_patient ;;

        sample)
            validate_patient

            add_sample ;;

        data)
            validate_patient
            validate_sample
            validate_files

            add_data ;;

        result)
            validate_patient
            validate_sample
            validate_files

            # TODO: marche aussi avec juste un revision_of sans sample ?
            # A result object needs to USE a data object
            [[ "${#USE[@]}" -gt 0 ]] || die "Please --use data when adding a result"

            add_result ;;

        diagnostic)
            validate_patient

            # A diagnostic needs to be at least revision_of another diagnostic, or use results or diagnostics,
            [[ "${#USE[@]}" -gt 0 ]] || [[ "$REVISION_OF" ]] || die "Please --use result|diagnostic or --revision_of diagnostic when adding a diagnostic"

            add_diagnostic ;;

        *) usage $VERB ;;
    esac

    commit

    echo -e "\033[0;32mAdded $OBJECT:$ID\033[0m
"
}

###############################################################################
#
# List functions

# List patients
# Uses : nothing
function list_patient
{
    local pat
    for pat in ls * --directory -1; do
        dbg git -C "$pat" rev-parse && echo "$pat"
    done
}

# List objects
# Uses :
# - PATIENT
# - [HASHES]
function list_object
{
    git log --format=%s --grep="^$OBJECT:" "${HASHES[@]}"
}

# List
function list
{
    case "$OBJECT" in
        patient)
            list_patient ;;

        sample|data|result|diagnostic)
            validate_patient
            validate_hashes
            list_object ;;
        *) usage $VERB ;;
    esac
}

###############################################################################

# Return the provenance in turtle format
# It is the concatenation of all commit messages (without the subject line)
function get_prov
{
    echo "@prefix xsd:  <http://www.w3.org/2001/XMLSchema#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix prov: <http://www.w3.org/ns/prov#> .
@prefix :     <http://gitommix.org/gitommix#> .

    $(git log --format='#%s %h%n%b' --author-date-order --reverse ${HASHES[@]})" | \
        rapper -i turtle - gitommix -eqo turtle
}

function turtle2dot
{
    rapper -i turtle - gitommix -eqo dot | \
        grep -Ev 'prov:generatedAtTime' | \
        grep -Ev 'xsd:dateTime' | \
        grep -Ev 'Rprov:' | \
        grep -Ev 'Rprovider:' | \
        grep -Ev '^\s*label=' | \
        sed -E \
            -e 's/(^\s*"Rpatient:.*color = )blue/\1black/' \
            -e 's/(^\s*"Rsample:.*color = )blue/\1black/' \
            -e 's/(^\s*"Rdata:.*color = )blue/\1black, fillcolor = "#9999FF", style = filled/' \
            -e 's/(^\s*"Rresult:.*color = )blue/\1black, fillcolor = "#99FF99", style = filled/' \
            -e 's/(^\s*"Rdiagnostic:.*color = )blue/\1black, fillcolor = "#FF9999", style = filled/' \
            -e 's/prov:wasDerivedFrom//'
}

function get_graph
{
    get_prov | \
        turtle2dot | \
        sed -E -e 's/rankdir = LR;/rankdir = BT;\n\tranksep = .3;\n\tnodesep = .8;/' | \
        dot -Tpng
}

function get_timeline
{
    echo "@prefix xsd:  <http://www.w3.org/2001/XMLSchema#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix prov: <http://www.w3.org/ns/prov#> .
@prefix :     <http://gitommix.org/gitommix#> .

    $(git log --grep '^diagnostic:' --format='# %s%n%b' --author-date-order --reverse "${HASHES[@]}")" | \
        grep -Ev ':result:' | \
        rapper -i turtle - gitommix -eqo turtle | \
        turtle2dot | \
        sed -E -e 's/rankdir = LR;/rankdir = RL;\n\tranksep = .3;\n\tnodesep = .8;/' | \
        dot -Tpng
}

function get_object
{
    git checkout "${HASHES[0]}"
}

# Get up-to-date result of a sample
# Print the last commit
function get_last
{
    git branch --list 'diagnostic|*' --list 'sample|*' --format='%(subject)' --contains "${HASHES[@]}"
}

# Print git commit log
function get_log
{
    git log --oneline --graph "${HASHES[@]}"
}

# Print the name of the files added by the objects
function get_file
{
    git diff-tree --no-commit-id --name-only "${HASHES[@]}" -r
}

function get
{
    validate_patient
    validate_hashes

    case "$OBJECT" in
        prov|last|timeline|object|graph|log|file) get_"$OBJECT" ;;
        *) usage $VERB ;;
    esac
}

###############################################################################
#
# Validation helpers

# Validate PATIENT and switch to it
function validate_patient
{
    [[ "$PATIENT" ]] || die "Please provide a --patient"
    dbg git -C "$PATIENT" rev-parse || die "patient:$PATIENT is not a patient"
    cd "$PATIENT" || die "Unable to acces the patient directory at: $GIT_OMMIX_REPO_DIR/$PATIENT
Please check your permissions"
}

# Validate SAMPLE and switch to it
function validate_sample
{
    [[ "$SAMPLE" ]] || die "Please provide a --sample"
    # check the sample exists and try to switch to it
    dbg git rev-parse --verify "sample|$SAMPLE" || die "sample:$SAMPLE is not a sample of patient:$PATIENT" && dbg stash git checkout "sample|$SAMPLE"
}

# Validate FILES and qualify path
function validate_files
{
    [[ "${#FILES[@]}" -gt 0 ]] || die "Please provide files to add"
    # Qualify FILES with their full path
    for ((i = 0; i < ${#FILES[@]}; i++));do
        FILES[i]="$CURRENT_DIR/${FILES[i]}"
    done
}

# Validate a commit given by its hash or id. It must match a type.
# Return the full name of the object
# $1 : type
# $2 : hash|id
function validate_commit
{
    # Remove prefix from names given in full
    HASH="$2"
    NAME="$(echo "$2" | sed -r "s/^$1://")"

    # If the commit is given by its object id,
    if git log --format="%s" --all | grep -E "^$1:$NAME$" --quiet;then
        HASH="$(git log --format="%h %s" --all | grep -E "\b$1:$NAME$" | cut -d ' ' -f 1)"
        NAME="$(git log --format=%s --max-count=1 "$HASH")"
    elif dbg git log "$HASH";then # find commit by its hash
        NAME="$(git log --format=%s --max-count=1 "$HASH")"
        # check that the commit matches the given type
        echo "$NAME" | grep -E "^$1:" --quiet || die "$HASH is not the commit hash of existing $1 of patient:$PATIENT"
    else
        die "$2 is neither the commit hash nor the name of existing $1 of patient:$PATIENT"
    fi
}

# Validate hashes or resolve and expand names given after a list verb
function validate_hashes
{
    local hash
    local out=()

    if [[ "${#HASHES[@]}" -gt 0 ]];then
        for hash in "${HASHES[@]}";do
            if git log --format="%s" --all | grep -E "$hash$" --quiet;then
                out+=($(git log --format="%h %s" --all | grep -E "$hash$" | cut -d ' ' -f 1))
            elif dbg git log "$hash";then
                out+=("$(git log --format=%h --max-count=1 "$hash")")
            else
                die "$hash is neither the commit hash nor the name of an existing object of patient:$PATIENT"
            fi
        done
        HASHES=("${out[@]}")
    else
        HASHES="--all"
    fi
}

###############################################################################
# Helpers

# Prepare the base components of the PROV message
function base_prov
{
    local provider="${PROVIDER%% <*}"
    provider="${provider/ /_}"

    MESSAGE_ACTIVITY=

    MESSAGE_AGENT="
:provider:$provider a prov:Agent ."

    MESSAGE_ENTITY="
:$OBJECT:$ID a prov:Entity .
:$OBJECT:$ID prov:wasAttributedTo :provider:$provider .
:$OBJECT:$ID prov:generatedAtTime xsd:dateTime:$DATE ."

    # Add a method PROV triplets if given
    if [[ "$METHOD" ]];then
        MESSAGE_ACTIVITY="
:method:$METHOD a prov:Activity .
:method:$METHOD startedAtTime xsd:dateTime:$DATE .
:method:$METHOD prov:wasAssociatedWith :provider:$provider ."

        MESSAGE_ENTITY+="
:$OBJECT:$ID prov:wasGeneratedBy :method:$METHOD ."
    fi
}

# Do the actual git commit with all the parameters set
function commit
{
    dbg git commit --allow-empty \
        --author "$PROVIDER" \
        --date "$DATE" \
        --message "$OBJECT:$ID
$MESSAGE_ENTITY
$MESSAGE_AGENT
$MESSAGE_ACTIVITY
$MESSAGE2"

    dbg git annex restage
}

# Validate and add relevant triplets for wasRevisionOf
# An $OBJECT can only be a revision_of another $OBJECT
function revision_of
{
    validate_commit "$OBJECT" "$REVISION_OF"

    MESSAGE_ENTITY+="
:$OBJECT:$ID prov:wasRevisionOf :$NAME ."
}

# Validate and add relevant triplets for wasInvalidated
function invalidate
{
    local inval
    local out_hash=()
    local out_name=()

    for inval in "${INVALIDATE[@]}";do
        validate_commit "$OBJECT" "$inval"
        out_hash+=("$HASH")
        out_name+=("$NAME")

        MESSAGE_ENTITY+="
:$NAME prov:invalidatedAtTime xsd:dateTime:$DATE ."

        if [[ "$METHOD" ]];then
            MESSAGE_ENTITY+="
:$NAME prov:wasInvalidatedBy :method:$METHOD ."
        fi
    done

    HASH=("${out_hash[@]}")
    NAME=("${out_name[@]}")
}

# Validate and add relevant triplets for wasDerivedFrom
# $1 : type
function use
{
    local use
    local out_hash=()
    local out_name=()

    for use in "${USE[@]}";do
        validate_commit "$1" "$use"
        out_hash+=("$HASH")
        out_name+=("$NAME")

        MESSAGE_ENTITY+="
:$OBJECT:$ID prov:wasDerivedFrom :$NAME ."

        if [[ "$METHOD" ]];then
            MESSAGE_ACTIVITY+="
:method:$METHOD used :$NAME ."
        fi
    done

    HASH=("${out_hash[@]}")
    NAME=("${out_name[@]}")
}
